const path = require('path');

const { scrapYoutube } = require(path.join(__dirname, 'handler.js'))


const xml2js = require('xml2js');

function extractSubtitles(html) {
    const ytInitialDataRegex = /var ytInitialPlayerResponse\s*=\s*(\{.*?\})\s*;/s;
    const match = html.match(ytInitialDataRegex);

    if (match && match[1]) {
        try {
            let jsonString = match[1];
            const lastBraceIndex = jsonString.lastIndexOf('}');
            jsonString = jsonString.substring(0, lastBraceIndex + 1);
            const jsonData = JSON.parse(jsonString);
            return jsonData;
        } catch (error) {
            return { error: 'json_parse_error' };
        }
    } else {
        return { error: 'no_data' };
    }
}




function requestSubtitles(videoId, html) {
    return new Promise(async (resolve, reject) => {
        try {
            if (!html) {
                html = await scrapYoutube(`https://www.youtube.com.eg/watch?v=${videoId}`, true)
            }
            const json = extractSubtitles(html)
            const captions = json?.captions?.playerCaptionsTracklistRenderer?.captionTracks || { error: 'no_captions' };
            let url

            if (!captions[0]?.name?.simpleText.includes('auto')) {
                url = captions[0]?.baseUrl;
            }

            let original
            let selected = captions[0]?.languageCode;

            try {
                for (let track of captions) {
                    if (track.languageCode == 'ar' || track.languageCode == 'en') {
                        original = track.languageCode
                        break;
                    }
                }

                for (let track of captions) {
                    if (track.languageCode == original && !track.name?.simpleText.includes('auto')) {
                        url = track.baseUrl
                        selected = track.languageCode
                        break;
                    }
                }
            } catch (e) {
                console.log(e)
            }

            if (!url) {
                return resolve({ error: 'no_lyrics', discriptions: 'no_captions_found' })
            }

            const data = await scrapYoutube(url, true);
            resolve(data)
        } catch (e) {
            resolve({ error: e.message })
        }
    });
}

function processSubtitles(subtitles) {
    return subtitles
        .map(subtitle => {
            let { start, end, text } = subtitle;
            if (text.match(/^\[.*\]$/)) {
                text = null;
            }
            if (text !== null) {
                text = text.replace(/â™ª/g, '').trim();
                text = text.toLowerCase().replace(/(^\w)|(\.\s*\w)|(\?\s*\w)|(\!\s*\w)/g, match => match.toUpperCase());
            }

            return { start, end, text };
        })
        .filter(subtitle => subtitle.text !== null && subtitle.text !== "");
}


async function getNativeSubtitles(videoId, html) {
    return new Promise(async (resolve, reject) => {
        try {
            const data = await requestSubtitles(videoId, html)
            xml2js.parseString(data, { trim: true }, (err, result) => {
                if (err) {
                    return resolve({ error: 'transform_error', xml: data })
                } else {
                    try {
                        const transformed = result?.transcript?.text.map(item => ({
                            text: item._,
                            start: parseFloat(item.$.start),
                            end: parseFloat(item.$.dur) + parseFloat(item.$.start)
                        }));
                        let jsonSrt = processSubtitles(transformed)
                        resolve({ api: 'youtube', lyrics: jsonSrt, autoGenerated: false })
                    } catch (e) {
                        resolve({ error: 'transform_error', xml: data })
                    }
                }
            });
        } catch (e) {
            resolve(e)
        }
    });
}


module.exports = { getNativeSubtitles, requestSubtitles }
